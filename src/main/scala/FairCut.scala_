/**
  * It's too difficult, I'll give up.
  * Created by liuwei on 10/16/16.
  */
object Solution {
  def main(args: Array[String]) {
    val fairCut = new FairCut(Array(4, 3, 1, 2))
    val result = fairCut.get(3, 2)
    println(result.minDifference)
  }

  def getOrElseUpdate[T](a: Array[T], index: Int, emptyValue: T)(compute: => T) = {
    var value = a(index)
    if (value == emptyValue) {
      value = compute
      a(index) = value
    }
    value
  }

  def getOrElseUpdate[T](a: Array[Array[T]], i: Int, j: Int, emptyValue: T)(compute: => T) = {
    var value = a(i)(j)
    if (value == emptyValue) {
      value = compute
      a(i)(j) = value
    }
    value
  }

  class FairCut(input: Array[Int]) {
    val a = input.sorted

    Console.println("input: " + a.toSeq)

    val length = a.length
    private val sum_ = Array.fill[Int](length + 1)(-1)

    def sum(end: Int): Int = getOrElseUpdate(sum_, end, -1) {
      if (end == 0) 0 else a(end - 1) + sum(end - 1)
    }

    def sum(start: Int, end: Int): Int = sum(end) - sum(start)

    case class State(sumInI: Int, sumInJ: Int, minDifference: Int) {}

    private val states_ = Array.ofDim[State](length + 1, length + 1)

    def get(end: Int, iCount: Int): State = {
      getOrElseUpdate(states_, end, iCount, null) {
        val resultState = {
          if (iCount == 0) {
            State(0, sum(end), 0)
          } else if (iCount == end) {
            State(sum(end), 0, 0)
          } else {
            val last = end - 1
            val lastElement = a(last)
            var minState: State = null

            // first try when put $end element to I
            {
              val oldICount = iCount - 1
              for (subend <- Range.inclusive(0, last)) {
                val subState = get(subend, oldICount)
                if (subState != null) {
                  val jCount = end - oldICount
                  val difference = subState.minDifference + lastElement * jCount - subState.sumInJ

                  if (minState == null || minState.minDifference > difference) {
                    minState = State(subState.sumInI + lastElement, subState.sumInJ, difference)
                  }
                }
              }
            }

            // try to put $end to J
            for (subend <- Range.inclusive(0, last)) {
              val subState = get(subend, iCount)
              if (subState != null) {
                val difference = subState.minDifference + lastElement * iCount - subState.sumInI
                if (minState == null || minState.minDifference > difference) {
                  minState = State(subState.sumInI, subState.sumInJ + lastElement, difference)
                }
              }
            }

            minState
          }
        }


        Console.err.println(s"end: $end, iCount: $iCount) => $resultState")
        resultState
      }
    }

  }

}
