/**
  * It's too difficult, I'll give up.
  * Created by liuwei on 10/16/16.
  */
object Solution {
  def main(args: Array[String]) {
    val fairCut = new FairCut(Array(4, 3, 1, 2))
    val result = fairCut.get(3, 2)
    println(result.minDifference)
  }

  def getOrElseUpdate[T](a: Array[T], index: Int, emptyValue: T)(compute: => T) = {
    var value = a(index)
    if (value == emptyValue) {
      value = compute
      a(index) = value
    }
    value
  }

  def getOrElseUpdate[T](a: Array[Array[T]], i: Int, j: Int, emptyValue: T)(compute: => T) = {
    var value = a(i)(j)
    if (value == emptyValue) {
      value = compute
      a(i)(j) = value
    }
    value
  }

  class FairCut(input: Array[Int]) {
    val a = input.sorted

    Console.println("input: " + a.toSeq)

    val length = a.length
    private val sum_ = Array.fill[Int](length + 1)(-1)

    def sum(end: Int): Int = getOrElseUpdate(sum_, end, -1) {
      if (end == 0) 0 else a(end - 1) + sum(end - 1)
    }

    def sum(start: Int, end: Int): Int = sum(end) - sum(start)

    case class State(sumInI: Int, sumInJ: Int, minDifference: Int) {}

    private val states_ = Array.ofDim[State](length + 1, length + 1)

    def diff(range: Range, sumOfAnotherGroup: Int, countOfAnotherGroup: Int) = range.map(a(_) * countOfAnotherGroup - sumOfAnotherGroup).sum

    def sum(range: Range): Int = sum(range.start, range.end)

    def get(end: Int, iCount: Int): State = {
      getOrElseUpdate(states_, end, iCount, null) {
        Console.err.println(s"get: end: $end, iCount: $iCount)")

        val resultState = {
          if (iCount == 0 || end == 0) {
            State(0, sum(end), 0)
          } else {
            val last = end - 1
            val lastElement = a(last)
            var minState: State = null

            {
              // first try when put $end element to I
              val oldICount = iCount - 1
              for (subend <- Range.inclusive(oldICount, last)) {

                val subState = get(subend, oldICount)
                if (subState != null) {
                  val additionalDiffInJ = diff(Range(subend, last), oldICount, subState.sumInI)
                  val addionalSumInJ = sum(subend, last)

                  Console.err.println(s"subEnd:$subend, last:$last additionalDiffInJ: $additionalDiffInJ, addionalSumInJ:$addionalSumInJ")

                  val difference = subState.minDifference +
                    additionalDiffInJ + // those in J need to diff with previous
                    diff(Range(last, end), end - oldICount, subState.sumInJ + addionalSumInJ)

                  if (minState == null || minState.minDifference > difference) {
                    minState = State(subState.sumInI + lastElement, subState.sumInJ + addionalSumInJ, difference)
                  }
                }
              }
            }

            for (subend <- Range.inclusive(iCount, last)) {
              {
                // try to put $end to J
                val subState = get(subend, iCount)
                if (subState != null) {
                  val difference = subState.minDifference +
                    diff(Range(subend, end), iCount, subState.sumInI)

                  if (minState == null || minState.minDifference > difference) {
                    minState = State(subState.sumInI, subState.sumInJ + sum(subend, end), difference)
                  }
                }

              }
            }

            minState
          }
        }

        Console.err.println(s"end: $end, iCount: $iCount) => $resultState")
        resultState
      }

    }

  }

}